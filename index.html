<!doctype html>
<html lang="ja">
<meta charset="utf-8" />
<title>åŒæ™‚ç¿»è¨³</title>
<style>
  body{font:14px/1.6 system-ui, sans-serif; max-width:800px; margin:40px auto; padding:0 16px;}
  .row{display:grid; grid-template-columns:120px 1fr; gap:8px; align-items:center}
  .bubble{padding:10px 12px; border-radius:12px; background:#f5f5f7; margin:6px 0; white-space:pre-wrap}
  .bubble.out{background:#e8f0fe}
  .bubble.tts{background:#fffbe6; border:1px solid #f3d36b}
  button{padding:8px 14px; border-radius:10px; border:1px solid #ccc; background:#fff; cursor:pointer}
  .small{opacity:.7; font-size:12px}
</style>
<body>
  <h1>åŒæ™‚ç¿»è¨³</h1>

  <div class="row">
    <label>å…¥åŠ›ã‚½ãƒ¼ã‚¹:</label>
    <select id="inputSource">
      <option value="microphone">ãƒã‚¤ã‚¯</option>
      <option value="text">ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›</option>
    </select>
  </div>
  <div class="row">
    <label>å…¥åŠ›è¨€èª:</label>
    <select id="srcLang">
      <option value="ja-JP">æ—¥æœ¬èª (ja-JP)</option>
      <option value="en-US">English (en-US)</option>
    </select>
  </div>
  <div class="row">
    <label>å‡ºåŠ›è¨€èª:</label>
    <select id="tgtLang">
      <option value="en">English</option>
      <option value="ja">æ—¥æœ¬èª</option>
    </select>
  </div>
  <div class="row">
    <label>Gemini API Key:</label>
    <input id="apiKey" type="password" placeholder="AIza..." style="width:100%" />
  </div>
  <div class="row">
    <label>ãƒ¢ãƒ‡ãƒ«å„ªå…ˆ:</label>
    <select id="modelPref">
      <option value="speed" selected>é€Ÿåº¦å„ªå…ˆ (flash)</option>
      <option value="quality">ç²¾åº¦å„ªå…ˆ (pro)</option>
    </select>
  </div>
  <div class="row">
    <label>ä½¿ç”¨ãƒ¢ãƒ‡ãƒ«:</label>
    <div id="modelInfo" class="small" style="min-height:18px">æœªé¸æŠ</div>
  </div>
  <p class="small">â€» AI Studioã®APIã‚­ãƒ¼ã¯<strong>å¿…ãšãƒªãƒ•ã‚¡ãƒ©åˆ¶é™</strong>ã‚’è¨­å®šã—ã¦ãã ã•ã„ã€‚æœ¬ç•ªã¯ã‚µãƒ¼ãƒå´ã§éš ã™ã®ãŒåŸå‰‡ã§ã™ã€‚</p>

  <div id="textInputArea" style="display:none; margin-bottom:16px;">
    <textarea id="textInput" placeholder="ç¿»è¨³ã—ãŸã„ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„" style="width:100%; min-height:100px; padding:8px; border-radius:8px; border:1px solid #ccc;"></textarea>
    <button id="translateBtn" style="margin-top:8px;">ç¿»è¨³ã™ã‚‹</button>
  </div>

  <p>
    <button id="btn">ğŸ™ï¸ éŸ³å£°å…¥åŠ›é–‹å§‹</button>
    <label><input type="checkbox" id="tts" checked> è¨³æ–‡ã‚’èª­ã¿ä¸Šã’ã‚‹</label>
  </p>

  <div id="orig" class="bubble"></div>
  <div id="tran" class="bubble out"></div>
  <!-- spokenã‚¨ãƒªã‚¢å‰Šé™¤: éŸ³å£°èª­ã¿ä¸Šã’ã®è¦–è¦šçš„é€²è¡Œè¡¨ç¤ºã¯å»ƒæ­¢ -->

<script>
const btn = document.getElementById('btn');
const orig = document.getElementById('orig');
const tran = document.getElementById('tran');
// spokenã‚¨ãƒªã‚¢å‰Šé™¤ã«ä¼´ã„DOMå‚ç…§ã‚’é™¤å»
const srcLang = document.getElementById('srcLang');
const tgtLang = document.getElementById('tgtLang');
const apiKeyInput = document.getElementById('apiKey');
const ttsOn = document.getElementById('tts');
const inputSource = document.getElementById('inputSource');
const textInputArea = document.getElementById('textInputArea');
const textInput = document.getElementById('textInput');
const translateBtn = document.getElementById('translateBtn');
const modelPref = document.getElementById('modelPref');
const modelInfo = document.getElementById('modelInfo');

let recog, running = false, partial = '';
let ttsProgressTimer = null; // TTSé€²è¡Œã®æ“¬ä¼¼ãƒã‚¤ãƒ©ã‚¤ãƒˆç”¨
let origText = ''; // åŸæ–‡ç´¯ç©ç”¨
let tranText = ''; // è¨³æ–‡ç´¯ç©ç”¨
let wakeLock = null; // Screen Wake Lock APIç”¨
let keepAliveInterval = null; // ã‚¹ãƒªãƒ¼ãƒ—é˜²æ­¢ç”¨ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«
let noSleepVideo = null; // ãƒ“ãƒ‡ã‚ªãƒˆãƒªãƒƒã‚¯ç”¨

// å…¥åŠ›ã‚½ãƒ¼ã‚¹åˆ‡ã‚Šæ›¿ãˆ
inputSource.addEventListener('change', () => {
  if (inputSource.value === 'text') {
    textInputArea.style.display = 'block';
    btn.style.display = 'none';
  } else {
    textInputArea.style.display = 'none';
    btn.style.display = 'inline-block';
  }
});

// ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›ã®ç¿»è¨³ãƒœã‚¿ãƒ³
translateBtn.onclick = async () => {
  const key = apiKeyInput.value.trim();
  if (!key) { alert('Gemini APIã‚­ãƒ¼ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„'); return; }
  
  const text = textInput.value.trim();
  if (!text) { alert('ç¿»è¨³ã™ã‚‹ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„'); return; }
  
  // finalChunkæ¤œå‡ºæ™‚ã¨åŒã˜å‡¦ç†
  const finalChunk = text;
  
  origText += finalChunk + '\n';
  orig.textContent = origText;
  
  console.log('[ç¿»è¨³ãƒªã‚¯ã‚¨ã‚¹ãƒˆ] åŸæ–‡:', finalChunk);
  const translated = await translateWithGemini(finalChunk, tgtLang.value, apiKeyInput.value);
  console.log('[ç¿»è¨³çµæœ]', translated || '(ç©º)');
  if (translated) {
    tranText += translated + '\n';
    tran.textContent = tranText;
    if (ttsOn.checked) speak(translated, tgtLang.value);
  }
  
  // ç¿»è¨³å¾Œã€ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒªã‚¢ã‚’ã‚¯ãƒªã‚¢
  textInput.value = '';
};

function ensureRecognition(lang) {
  const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
  if (!SR) { alert('ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯ Web Speech API (SpeechRecognition) ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã›ã‚“ã€‚Chromeã‚’ãŠè©¦ã—ãã ã•ã„ã€‚'); return null; }
  const r = new SR();
  r.lang = lang;
  r.interimResults = true;
  r.continuous = true;
  return r;
}

btn.onclick = () => {
  if (!running) start(); else stop();
};

function start() {
  const key = apiKeyInput.value.trim();
  if (!key) { alert('Gemini APIã‚­ãƒ¼ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„'); return; }

  recog = ensureRecognition(srcLang.value);
  if (!recog) return;

  running = true;
  btn.textContent = 'â¹ï¸ åœæ­¢';
  orig.textContent = ''; tran.textContent = '';
  origText = ''; tranText = ''; // ç´¯ç©ãƒãƒƒãƒ•ã‚¡ãƒªã‚»ãƒƒãƒˆ

  // Screen Wake Lockã‚’å–å¾—ã—ã¦ã‚¹ãƒªãƒ¼ãƒ—ã‚’é˜²æ­¢
  requestWakeLock();
  
  // è¿½åŠ ã®ã‚¹ãƒªãƒ¼ãƒ—é˜²æ­¢ç­–
  startKeepAlive();

  recog.onresult = async (ev) => {
    let finalChunk = '';
    let currentPartial = '';
    
    // æ–°ã—ã„çµæœã®ã¿ã‚’å‡¦ç†ï¼ˆresultIndexã‹ã‚‰é–‹å§‹ï¼‰
    for (let i = ev.resultIndex; i < ev.results.length; i++) {
      const res = ev.results[i];
      const txt = res[0].transcript;
      if (res.isFinal) {
        finalChunk += txt;
      } else {
        currentPartial += txt;
      }
    }
    
    // partialã‚’æ›´æ–°
    if (currentPartial) {
      partial = currentPartial;
    }
    
    // ç”»é¢ã®å­—å¹•æ›´æ–°
    if (finalChunk) {
      origText += finalChunk + '\n';
    }
    orig.textContent = origText + (partial ? ('â€¦' + partial) : '');

    // finalãŒå‡ºãŸã‚‰ç¿»è¨³ã‚’å©ãï¼ˆçŸ­æ–‡å˜ä½ï¼‰
    if (finalChunk) {
      console.log('[ç¿»è¨³ãƒªã‚¯ã‚¨ã‚¹ãƒˆ] åŸæ–‡:', finalChunk);
      const translated = await translateWithGemini(finalChunk, tgtLang.value, apiKeyInput.value);
      console.log('[ç¿»è¨³çµæœ]', translated || '(ç©º)');
      if (translated) {
        tranText += translated + '\n';
        tran.textContent = tranText;
        if (ttsOn.checked) speak(translated, tgtLang.value);
      }
      partial = '';
    }
  };

  recog.onerror = (e) => console.warn('STT error', e);
  recog.onend = () => { if (running) recog.start(); }; // è‡ªå‹•å†é–‹
  recog.start();
}

async function stop() {
  running = false;
  btn.textContent = 'ğŸ™ï¸ éŸ³å£°å…¥åŠ›é–‹å§‹';
  try { recog && recog.stop(); } catch {}
  
  // Wake Lockã‚’è§£æ”¾
  releaseWakeLock();
  
  // ã‚¹ãƒªãƒ¼ãƒ—é˜²æ­¢ç­–ã‚’åœæ­¢
  stopKeepAlive();
  
  // åœæ­¢æ™‚ã«æ®‹ã£ã¦ã„ã‚‹partialãƒ†ã‚­ã‚¹ãƒˆãŒã‚ã‚Œã°ç¿»è¨³ã™ã‚‹
  if (partial) {
    const finalChunk = partial;
    partial = '';
    
    origText += finalChunk + '\n';
    orig.textContent = origText;
    
    console.log('[ç¿»è¨³ãƒªã‚¯ã‚¨ã‚¹ãƒˆ] åŸæ–‡:', finalChunk);
    const translated = await translateWithGemini(finalChunk, tgtLang.value, apiKeyInput.value);
    console.log('[ç¿»è¨³çµæœ]', translated || '(ç©º)');
    if (translated) {
      tranText += translated + '\n';
      tran.textContent = tranText;
      if (ttsOn.checked) speak(translated, tgtLang.value);
    }
  }
}

// ===== Gemini API ç¿»è¨³ï¼ˆãƒ¢ãƒ‡ãƒ«è‡ªå‹•æ¤œå‡º + v1/v1beta ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰ =====
// åˆ©ç”¨å®‰å®šåº¦ã‚’è€ƒæ…®ã—ã¦ 2.x å®Ÿé¨“ç³»ã¯é™¤å¤–ï¼ˆ400/404é »ç™ºå›é¿ï¼‰
const PREFERRED_MODELS = [
  'gemini-1.5-flash',
  'gemini-1.5-flash-001',
  'gemini-1.5-pro',
  'gemini-pro'
];
let activeModel = null;      // ä¾‹: 'gemini-1.5-flash'
let activeApiVersion = null; // 'v1' | 'v1beta'
let modelPreference = 'speed'; // 'speed' | 'quality'

async function listModels(version, apiKey) {
  const url = `https://generativelanguage.googleapis.com/${version}/models?key=${encodeURIComponent(apiKey)}`;
  const res = await fetch(url);
  if (!res.ok) {
    const t = await res.text();
    throw new Error(`${version}: ${res.status} ${t.slice(0,160)}`);
  }
  return res.json();
}

function pickBestModel(models) {
  // models[i].name ã¯ 'models/gemini-xxx' å½¢å¼
  const candidates = models
    .filter(m => Array.isArray(m.supportedGenerationMethods) && m.supportedGenerationMethods.includes('generateContent'))
    .map(m => (m.name || '').replace(/^models\//, ''))
    .filter(n => n && !/vision|embed|embedding|exp|experimental|2\./i.test(n)); // 2.x ã¨ experimental ã‚’é™¤å¤–

  if (!candidates.length) return null;
  // å‹•çš„å„ªå…ˆé †ä½ä½œæˆ
  let ordered;
  if (modelPreference === 'quality') {
    // ç²¾åº¦å„ªå…ˆ: pro -> flash
    ordered = [
      'gemini-1.5-pro','gemini-pro','gemini-1.5-flash','gemini-1.5-flash-001'
    ];
  } else {
    // é€Ÿåº¦å„ªå…ˆ: flash -> pro
    ordered = [
      'gemini-1.5-flash','gemini-1.5-flash-001','gemini-1.5-pro','gemini-pro'
    ];
  }
  for (const name of ordered) {
    if (candidates.includes(name)) return name;
  }
  // fallback: flashç³» or æœ€åˆ
  const flash = candidates.find(n => /flash/i.test(n));
  return flash || candidates[0];
}

async function ensureModel(apiKey) {
  if (activeModel && activeApiVersion) return { model: activeModel, version: activeApiVersion };
  const errors = [];
  for (const version of ['v1', 'v1beta']) {
    try {
      const data = await listModels(version, apiKey);
      const model = pickBestModel(data.models || []);
      if (model) {
        activeModel = model;
        activeApiVersion = version;
  modelInfo.textContent = `${model} (${version})`;
        return { model, version };
      } else {
        errors.push(`${version}: é©åˆãƒ¢ãƒ‡ãƒ«ãªã—`);
      }
    } catch (e) {
      errors.push(e.message);
    }
  }
  throw new Error('ãƒ¢ãƒ‡ãƒ«ä¸€è¦§ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ\n' + errors.join('\n'));
}

async function translateWithGemini(text, targetLang, apiKey) {
  // å‡ºåŠ›ã«æ—¥æœ¬èªã®æ³¨é‡ˆã‚„å€™è£œåˆ—æŒ™ã‚’å«ã‚ãªã„ã‚ˆã†å³æ ¼ã«æŒ‡ç¤ºã™ã‚‹ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
  const langLabel = (targetLang === 'en') ? 'è‹±èª' : (targetLang === 'ja' ? 'æ—¥æœ¬èª' : targetLang);
  const prompt = `ä»¥ä¸‹ã®åŸæ–‡ã‚’${langLabel}ã«è‡ªç„¶ã§ç°¡æ½”ã«ç¿»è¨³ã—ã¦ãã ã•ã„ã€‚\nå³å®ˆäº‹é …:\n- å‡ºåŠ›ã¯ç¿»è¨³çµæœæœ¬æ–‡ã®ã¿ã€‚ä¸€åˆ‡ã®æ³¨é‡ˆã€è£œè¶³èª¬æ˜ã€æ—¥æœ¬èªã§ã®è§£èª¬ã€å€™è£œã®åˆ—æŒ™ã€æ‹¬å¼§å†…ã‚³ãƒ¡ãƒ³ãƒˆã€ä¾‹ç¤ºã€èªå°¾ãƒãƒªã‚¨ãƒ¼ã‚·ãƒ§ãƒ³æç¤ºã‚’å«ã‚ãªã„ã€‚\n- è¤‡æ•°æ¡ˆãŒè€ƒãˆã‚‰ã‚Œã¦ã‚‚æœ€ã‚‚è‡ªç„¶ã§å˜ä¸€ã®1æ¡ˆã®ã¿ã‚’è¿”ã™ã€‚\n- ç®‡æ¡æ›¸ãè¨˜å·(*,-,ãƒ»ãªã©)ã‚„ä½™è¨ˆãªå¼•ç”¨ç¬¦/å›²ã¿è¨˜å·ã‚’å…ˆé ­ã‚„æœ«å°¾ã«ä»˜ã‘ãªã„ã€‚\n- åŸæ–‡ã®æ„å‘³ä¿æŒã‚’å„ªå…ˆã—ã¤ã¤å†—é•·ã•ã¯é¿ã‘ã‚‹ã€‚\nåŸæ–‡: """${text}"""`;

  const errors = [];
  // æœ€å¤§2å›ã®è©¦è¡Œ: 1å›ç›®ã¯ ensureModel ãŒé¸ã‚“ã  version/modelã€å¤±æ•—ã—ãŸã‚‰ã‚­ãƒ£ãƒƒã‚·ãƒ¥ç ´æ£„ã—ã¦é€†ã® version ã‚’è©¦ã™
  for (let attempt = 0; attempt < 4; attempt++) { // ä½™åˆ†ã«æœ€å¤§4è©¦è¡Œ (v1/v1beta * è¤‡æ•°ãƒ¢ãƒ‡ãƒ«å†æ¤œå‡º)
    try {
      const { model, version } = await ensureModel(apiKey);
      const url = `https://generativelanguage.googleapis.com/${version}/models/${model}:generateContent?key=${encodeURIComponent(apiKey)}`;
  modelInfo.textContent = `${model} (${version})`;
      const res = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          contents: [{ role: 'user', parts: [{ text: prompt }]}],
          generationConfig: { response_mime_type: 'text/plain' }
        })
      });
      if (!res.ok) {
        const errText = await res.text();
        errors.push(`${version}/${model}: ${res.status} ${errText.slice(0,160)}`);
        // 400/404 ã¯ãƒ¢ãƒ‡ãƒ«éå¯¾å¿œ or æ¨©é™ä¸è¶³ã®å¯èƒ½æ€§ â†’ ã‚­ãƒ£ãƒƒã‚·ãƒ¥ç ´æ£„ã—ã¦å†æ¤œå‡º
        activeModel = null; activeApiVersion = null;
        modelInfo.textContent = 'å†æ¤œå‡ºä¸­â€¦';
        continue;
      }
      const data = await res.json();
      const out = data?.candidates?.[0]?.content?.parts?.map(p => p.text).join('') ?? '';
      const trimmed = out.trim();
      if (trimmed) return trimmed;
      errors.push(`${version}/${model}: å¿œç­”ç©º`);
      activeModel = null; activeApiVersion = null;
      modelInfo.textContent = 'å†æ¤œå‡ºä¸­â€¦';
    } catch (e) {
      errors.push(e.message);
      activeModel = null; activeApiVersion = null;
      modelInfo.textContent = 'å†æ¤œå‡ºä¸­â€¦';
    }
  }

  const msg = '[ç¿»è¨³ã‚¨ãƒ©ãƒ¼] åˆ©ç”¨å¯èƒ½ãªãƒ¢ãƒ‡ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ\n' + errors.join('\n');
  tran.textContent = msg;
  return '';
}

// ãƒ¢ãƒ‡ãƒ«å„ªå…ˆåº¦å¤‰æ›´
modelPref.addEventListener('change', () => {
  modelPreference = modelPref.value;
  // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ç ´æ£„ã—å†æ¤œå‡ºã•ã›ã‚‹
  activeModel = null;
  activeApiVersion = null;
  modelInfo.textContent = 'æœªé¸æŠ (å†æ¤œå‡ºå¾…ã¡)';
});

// ãƒ–ãƒ©ã‚¦ã‚¶TTS
function speak(text, langCode) {
  // spokenã‚¨ãƒªã‚¢å‰Šé™¤å¾Œã¯å˜ç´”ã«éŸ³å£°èª­ã¿ä¸Šã’ã®ã¿ã‚’è¡Œã†
  try {
    const u = new SpeechSynthesisUtterance(text);
    u.lang = (langCode === 'ja') ? 'ja-JP' : (langCode === 'en' ? 'en-US' : langCode);
    speechSynthesis.cancel();
    speechSynthesis.speak(u);
  } catch {}
}

// å®‰å…¨ãªHTMLã‚¨ã‚¹ã‚±ãƒ¼ãƒ—
function escapeHTML(s){
  return s.replace(/[&<>"']/g,c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[c]));
}

// spokenã‚¨ãƒªã‚¢å‰Šé™¤ã«ã¤ã TTS ON/OFF ã¯èª­ã¿ä¸Šã’å®Ÿè¡Œå¯å¦ã®ã¿ï¼ˆUIè¡¨ç¤ºå¤‰æ›´ä¸è¦ï¼‰
ttsOn.addEventListener('change', () => {
  if (!ttsOn.checked) {
    speechSynthesis.cancel();
  }
});

// ===== Screen Wake Lock API: ã‚¹ãƒªãƒ¼ãƒ—é˜²æ­¢ =====
async function requestWakeLock() {
  if ('wakeLock' in navigator) {
    try {
      wakeLock = await navigator.wakeLock.request('screen');
      console.log('Wake Lock å–å¾—æˆåŠŸ');
      
      // ç”»é¢ãŒå†ã³è¡¨ç¤ºã•ã‚ŒãŸæ™‚ã«Wake Lockã‚’å†å–å¾—
      wakeLock.addEventListener('release', () => {
        console.log('Wake Lock è§£æ”¾');
      });
    } catch (err) {
      console.warn('Wake Lock å–å¾—å¤±æ•—:', err);
    }
  }
}

function releaseWakeLock() {
  if (wakeLock !== null) {
    wakeLock.release()
      .then(() => {
        wakeLock = null;
        console.log('Wake Lock æ‰‹å‹•è§£æ”¾');
      })
      .catch(err => console.warn('Wake Lock è§£æ”¾ã‚¨ãƒ©ãƒ¼:', err));
  }
}

// ===== è¿½åŠ ã®ã‚¹ãƒªãƒ¼ãƒ—é˜²æ­¢ç­– =====
function startKeepAlive() {
  // 1. ãƒ“ãƒ‡ã‚ªãƒˆãƒªãƒƒã‚¯ã§ã‚¹ãƒªãƒ¼ãƒ—ã‚’é˜²æ­¢ï¼ˆiOS Safariç­‰ã§æœ‰åŠ¹ï¼‰
  if (!noSleepVideo) {
    noSleepVideo = document.createElement('video');
    noSleepVideo.setAttribute('muted', '');
    noSleepVideo.setAttribute('playsinline', '');
    noSleepVideo.setAttribute('style', 'position:fixed;top:-1px;left:-1px;width:1px;height:1px;opacity:0.01;');
    // ç„¡éŸ³ã®WebMãƒ“ãƒ‡ã‚ªï¼ˆ1ç§’ãƒ«ãƒ¼ãƒ—ï¼‰
    noSleepVideo.src = 'data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQRChYECGFOAZwH/////////FUmpZpkq17GDD0JATYCGQ2hyb21lV0GGQ2hyb21lFlSua7+uvdeBAXPFh1dBVMWGQH8BAAAAAAADnQEAAAAAAABZU2XMU3ETnQQAAAAAAABTEa4BAABNiHAE+gOnBg0AIJGDAfqDnQdY+gqBlg4KQQAQJC9mAAoTEgJBqwkGlwJCm2IBrwUDmgbShAEB2QOdBAEB';
    noSleepVideo.loop = true;
    document.body.appendChild(noSleepVideo);
  }
  noSleepVideo.play().catch(e => console.warn('ãƒ“ãƒ‡ã‚ªå†ç”Ÿå¤±æ•—:', e));
  
  // 2. å®šæœŸçš„ã«éŸ³å£°èªè­˜ã®çŠ¶æ…‹ã‚’ç¢ºèªã—å†èµ·å‹•ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
  keepAliveInterval = setInterval(() => {
    if (running && recog) {
      // éŸ³å£°èªè­˜ãŒæ„å›³ã›ãšåœæ­¢ã—ã¦ã„ãŸã‚‰å†èµ·å‹•
      try {
        // Web Speech APIã«ã¯çŠ¶æ…‹ç¢ºèªãƒ¡ã‚½ãƒƒãƒ‰ãŒãªã„ãŸã‚ã€
        // onendã‚¤ãƒ™ãƒ³ãƒˆã§è‡ªå‹•å†é–‹ã•ã‚Œã‚‹ä»•çµ„ã¿ã«ä¾å­˜
        console.log('KeepAlive: å®Ÿè¡Œä¸­');
      } catch (e) {
        console.warn('KeepAlive ã‚¨ãƒ©ãƒ¼:', e);
      }
    }
  }, 30000); // 30ç§’ã”ã¨
}

function stopKeepAlive() {
  // ãƒ“ãƒ‡ã‚ªåœæ­¢
  if (noSleepVideo) {
    noSleepVideo.pause();
    noSleepVideo.currentTime = 0;
  }
  
  // ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«åœæ­¢
  if (keepAliveInterval) {
    clearInterval(keepAliveInterval);
    keepAliveInterval = null;
  }
}

// ãƒšãƒ¼ã‚¸ãŒå†ã³è¡¨ç¤ºã•ã‚ŒãŸæ™‚ã«Wake Lockã‚’å†å–å¾—
document.addEventListener('visibilitychange', async () => {
  if (wakeLock !== null && document.visibilityState === 'visible' && running) {
    await requestWakeLock();
  }
});
</script>
</body>
</html>
