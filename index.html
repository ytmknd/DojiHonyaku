<!doctype html>
<html lang="ja">
<meta charset="utf-8" />
<title>Frontend-only Simul-Translate (PoC)</title>
<style>
  body{font:14px/1.6 system-ui, sans-serif; max-width:800px; margin:40px auto; padding:0 16px;}
  .row{display:grid; grid-template-columns:120px 1fr; gap:8px; align-items:center}
  .bubble{padding:10px 12px; border-radius:12px; background:#f5f5f7; margin:6px 0; white-space:pre-wrap}
  .bubble.out{background:#e8f0fe}
  .bubble.tts{background:#fffbe6; border:1px solid #f3d36b}
  button{padding:8px 14px; border-radius:10px; border:1px solid #ccc; background:#fff; cursor:pointer}
  .small{opacity:.7; font-size:12px}
</style>
<body>
  <h1>ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã ã‘ã§åŒæ™‚ç¿»è¨³ï¼ˆPoCï¼‰</h1>

  <div class="row">
    <label>å…¥åŠ›è¨€èª:</label>
    <select id="srcLang">
      <option value="ja-JP">æ—¥æœ¬èª (ja-JP)</option>
      <option value="en-US">English (en-US)</option>
    </select>
  </div>
  <div class="row">
    <label>å‡ºåŠ›è¨€èª:</label>
    <select id="tgtLang">
      <option value="en">English</option>
      <option value="ja">æ—¥æœ¬èª</option>
    </select>
  </div>
  <div class="row">
    <label>Gemini API Key:</label>
    <input id="apiKey" type="password" placeholder="AIza..." style="width:100%" />
  </div>
  <p class="small">â€» AI Studioã®APIã‚­ãƒ¼ã¯<strong>å¿…ãšãƒªãƒ•ã‚¡ãƒ©åˆ¶é™</strong>ã‚’è¨­å®šã—ã¦ãã ã•ã„ã€‚æœ¬ç•ªã¯ã‚µãƒ¼ãƒå´ã§éš ã™ã®ãŒåŸå‰‡ã§ã™ã€‚</p>

  <p>
    <button id="btn">ğŸ™ï¸ éŸ³å£°å…¥åŠ›é–‹å§‹</button>
    <label><input type="checkbox" id="tts" checked> è¨³æ–‡ã‚’èª­ã¿ä¸Šã’ã‚‹</label>
  </p>

  <div id="orig" class="bubble"></div>
  <div id="tran" class="bubble out"></div>
  <div id="spoken" class="bubble tts" style="display:none"></div>

<script>
const btn = document.getElementById('btn');
const orig = document.getElementById('orig');
const tran = document.getElementById('tran');
const spoken = document.getElementById('spoken');
const srcLang = document.getElementById('srcLang');
const tgtLang = document.getElementById('tgtLang');
const apiKeyInput = document.getElementById('apiKey');
const ttsOn = document.getElementById('tts');

let recog, running = false, partial = '';
let ttsProgressTimer = null; // TTSé€²è¡Œã®æ“¬ä¼¼ãƒã‚¤ãƒ©ã‚¤ãƒˆç”¨
let origText = ''; // åŸæ–‡ç´¯ç©ç”¨
let tranText = ''; // è¨³æ–‡ç´¯ç©ç”¨

function ensureRecognition(lang) {
  const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
  if (!SR) { alert('ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯ Web Speech API (SpeechRecognition) ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã›ã‚“ã€‚Chromeã‚’ãŠè©¦ã—ãã ã•ã„ã€‚'); return null; }
  const r = new SR();
  r.lang = lang;
  r.interimResults = true;
  r.continuous = true;
  return r;
}

btn.onclick = () => {
  if (!running) start(); else stop();
};

function start() {
  const key = apiKeyInput.value.trim();
  if (!key) { alert('Gemini APIã‚­ãƒ¼ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„'); return; }

  recog = ensureRecognition(srcLang.value);
  if (!recog) return;

  running = true;
  btn.textContent = 'â¹ï¸ åœæ­¢';
  orig.textContent = ''; tran.textContent = '';
  origText = ''; tranText = ''; // ç´¯ç©ãƒãƒƒãƒ•ã‚¡ãƒªã‚»ãƒƒãƒˆ

  recog.onresult = async (ev) => {
    let finalChunk = '';
    for (let i = ev.resultIndex; i < ev.results.length; i++) {
      const res = ev.results[i];
      const txt = res[0].transcript;
      if (res.isFinal) {
        finalChunk += txt;
      } else {
        partial = txt;
      }
    }
    // ç”»é¢ã®å­—å¹•æ›´æ–°
    if (finalChunk) {
      origText += finalChunk + '\n';
    }
    orig.textContent = origText + (partial ? ('â€¦' + partial) : '');

    // finalãŒå‡ºãŸã‚‰ç¿»è¨³ã‚’å©ãï¼ˆçŸ­æ–‡å˜ä½ï¼‰
    if (finalChunk) {
      console.log('[ç¿»è¨³ãƒªã‚¯ã‚¨ã‚¹ãƒˆ] åŸæ–‡:', finalChunk);
      const translated = await translateWithGemini(finalChunk, tgtLang.value, apiKeyInput.value);
      console.log('[ç¿»è¨³çµæœ]', translated || '(ç©º)');
      if (translated) {
        tranText += translated + '\n';
        tran.textContent = tranText;
        if (ttsOn.checked) speak(translated, tgtLang.value);
      }
      partial = '';
    }
  };

  recog.onerror = (e) => console.warn('STT error', e);
  recog.onend = () => { if (running) recog.start(); }; // è‡ªå‹•å†é–‹
  recog.start();
}

function stop() {
  running = false;
  btn.textContent = 'ğŸ™ï¸ éŸ³å£°å…¥åŠ›é–‹å§‹';
  try { recog && recog.stop(); } catch {}
}

// Gemini APIã§ç¿»è¨³ï¼ˆè¶…ç°¡æ˜“ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆï¼‰
async function translateWithGemini(text, targetLang, apiKey) {
  const model = 'gemini-1.5-flash-latest';
  const prompt = `æ¬¡ã®æ–‡ã‚’${targetLang}ã«è‡ªç„¶ã«ç¿»è¨³ã—ã¦ãã ã•ã„ã€‚å›ºæœ‰åè©ã¯åŸæ–‡ã‚’å„ªå…ˆã—ã€æ„å‘³ãŒæ›–æ˜§ãªã‚‰ç°¡æ½”ã«è¨€ã„æ›ãˆã¦ãã ã•ã„ã€‚\nåŸæ–‡: """${text}"""`;

  try {
    const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${encodeURIComponent(apiKey)}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ contents: [{ parts: [{ text: prompt }]}] })
    });
    if (!res.ok) {
      const errText = await res.text();
      console.error('[ç¿»è¨³APIå¤±æ•—]', res.status, errText);
      throw new Error(errText);
    }
    const data = await res.json();
    const out = data?.candidates?.[0]?.content?.parts?.map(p => p.text).join('') ?? '';
    return out.trim();
  } catch (e) {
    console.error('[ç¿»è¨³ã‚¨ãƒ©ãƒ¼]', e);
    return '';
  }
}

// ãƒ–ãƒ©ã‚¦ã‚¶TTS
function speak(text, langCode) {
  try {
    const u = new SpeechSynthesisUtterance(text);
    // è¨€èªã‚’æ¨å®šè¨­å®šï¼ˆen/jaãªã©ï¼‰
    u.lang = (langCode === 'ja') ? 'ja-JP' : (langCode === 'en' ? 'en-US' : langCode);

    // è¡¨ç¤ºã‚¨ãƒªã‚¢æ›´æ–°ï¼ˆèª­ã¿ä¸Šã’ä¸­ã®è¨³æ–‡ï¼‰
    spoken.style.display = 'block';
    spoken.textContent = text;
    spoken.dataset.full = text; // ä¿æŒ
    spoken.title = 'ç¾åœ¨èª­ã¿ä¸Šã’ä¸­ã®è¨³æ–‡';

    // é€”ä¸­çµŒéãƒã‚¤ãƒ©ã‚¤ãƒˆï¼ˆãƒ–ãƒ©ã‚¦ã‚¶ã«ã‚ˆã£ã¦ boundary ãŒæ¥ãªã„å ´åˆã‚ã‚Šï¼‰
    const full = spoken.dataset.full || text;
    const setHighlight = (idx) => {
      const ci = Math.max(0, Math.min(full.length, idx|0));
      const shown = full.slice(0, ci);
      const rest = full.slice(ci);
      spoken.innerHTML = '<strong>' + escapeHTML(shown) + '</strong>' + escapeHTML(rest);
    };

    const clearTimer = () => {
      if (ttsProgressTimer) { clearInterval(ttsProgressTimer); ttsProgressTimer = null; }
    };

    let boundarySeen = false;
    let startTs = 0;

    u.onboundary = (e) => {
      boundarySeen = true;
      if (typeof e.charIndex === 'number') {
        setHighlight(e.charIndex);
      }
    };
    u.onstart = () => {
      spoken.style.opacity = 1;
      startTs = performance.now();
      // Chrome/Windowsç­‰ã§ boundary ãŒæ¥ãªã„å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
      setTimeout(() => {
        if (!boundarySeen && !ttsProgressTimer) {
          // è¨€èªã”ã¨ã®æ¦‚ç®—: ja ~7cps, en ~12cps ã‚’ãƒ™ãƒ¼ã‚¹ã« rate ã‚’ä¹—ç®—
          const baseCps = (u.lang && u.lang.startsWith('ja')) ? 7 : 12;
          const cps = baseCps * (u.rate || 1);
          clearTimer();
          ttsProgressTimer = setInterval(() => {
            const elapsed = (performance.now() - startTs) / 1000;
            const idx = Math.floor(elapsed * cps);
            if (idx >= full.length) {
              setHighlight(full.length);
              clearTimer();
            } else {
              setHighlight(idx);
            }
          }, 60);
        }
      }, 300);
    };
    u.onend = () => {
      clearTimer();
      // èª­ã¿ä¸Šã’çµ‚äº†å¾Œã‚°ãƒ¬ãƒ¼ã‚¢ã‚¦ãƒˆ
      spoken.innerHTML = escapeHTML(full);
      spoken.style.opacity = .7;
      setTimeout(() => { spoken.style.opacity = 1; }, 800);
    };

    speechSynthesis.cancel();
    // ç›´å‰ã®æ“¬ä¼¼é€²è¡Œã‚¿ã‚¤ãƒãƒ¼ã‚‚åœæ­¢
    if (ttsProgressTimer) { clearInterval(ttsProgressTimer); ttsProgressTimer = null; }
    speechSynthesis.speak(u);
  } catch {}
}

// å®‰å…¨ãªHTMLã‚¨ã‚¹ã‚±ãƒ¼ãƒ—
function escapeHTML(s){
  return s.replace(/[&<>"']/g,c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[c]));
}

// TTSè¡¨ç¤ºã®ON/OFFã«åˆã‚ã›ã¦è¡¨ç¤ºåˆ‡æ›¿
ttsOn.addEventListener('change', () => {
  if (!ttsOn.checked) {
    spoken.style.display = 'none';
  } else if (spoken.dataset.full) {
    spoken.style.display = 'block';
  }
});
</script>
</body>
</html>
